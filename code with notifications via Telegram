import ccxt
import time
import logging
import asyncio
from telegram import Bot

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Список бирж для арбитража
exchanges = {
    'binance': ccxt.binance(),
    'kraken': ccxt.kraken(),
    'coinbasepro': ccxt.coinbasepro()
}

# Товар для арбитража (например, BTC/USDT)
symbol = 'BTC/USDT'

# Минимальная разница для арбитража (в процентах)
min_arbitrage_percentage = 0.5

# Инициализация Telegram-бота
TELEGRAM_TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN'  # Замените на ваш токен
CHAT_ID = 'YOUR_CHAT_ID'  # Замените на ваш Chat ID
bot = Bot(token=TELEGRAM_TOKEN)

# Функция для получения цены с биржи
async def fetch_price(exchange, symbol):
    try:
        ticker = await exchange.fetch_ticker(symbol)
        return ticker['ask']  # или 'bid', в зависимости от того, что вам нужно
    except Exception as e:
        logger.error(f"Error fetching price from {exchange.name}: {e}")
        return None

# Функция для отправки сообщений в Telegram
def send_telegram_message(message):
    try:
        bot.send_message(chat_id=CHAT_ID, text=message)
    except Exception as e:
        logger.error(f"Error sending Telegram message: {e}")

# Основная функция для проверки арбитражных возможностей
async def check_arbitrage_opportunity():
    prices = {}

    # Получаем цены с каждой биржи
    tasks = []
    for name, exchange in exchanges.items():
        tasks.append(fetch_price(exchange, symbol))
    
    # Асинхронно получаем цены
    results = await asyncio.gather(*tasks)

    for i, price in enumerate(results):
        if price:
            exchange_name = list(exchanges.keys())[i]
            prices[exchange_name] = price
            logger.info(f"Price on {exchange_name}: {price}")

    # Находим максимальную и минимальную цену
    if len(prices) > 1:
        max_price = max(prices.values())
        min_price = min(prices.values())

        # Вычисляем разницу в процентах
        price_diff_percentage = ((max_price - min_price) / min_price) * 100

        logger.info(f"Max price: {max_price}, Min price: {min_price}")
        logger.info(f"Price difference: {price_diff_percentage:.2f}%")

        # Проверяем, если разница превышает порог
        if price_diff_percentage >= min_arbitrage_percentage:
            message = f"Arbitrage opportunity detected!\nPrice difference: {price_diff_percentage:.2f}%\nMax price: {max_price}\nMin price: {min_price}"
            logger.info(message)
            send_telegram_message(message)
        else:
            logger.info("No arbitrage opportunity.")
    else:
        logger.warning("Not enough exchanges to compare prices.")

# Функция для запуска бота
async def run_bot():
    while True:
        logger.info("\nChecking for arbitrage opportunities...")
        await check_arbitrage_opportunity()
        await asyncio.sleep(10)  # Ожидаем 10 секунд перед следующим запросом

if __name__ == '__main__':
    try:
        asyncio.run(run_bot())
    except Exception as e:
        logger.error(f"Error running bot: {e}")
